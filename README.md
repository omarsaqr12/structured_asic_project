# Structured ASIC Physical Design Flow

Implementation of a complete physical design flow (Placement, CTS, Routing, and STA) for a structured ASIC platform, as part of the **[CSCE330401 - Digital Design II]** project.

---

## Project Overview

This project implements an optimized placement engine for mapping logical cells from synthesized designs onto physical fabric slots in a structured ASIC architecture. The placement flow consists of two main phases:

1. **Greedy Barycenter Placement** - Fast initial placement using connectivity-driven heuristics
2. **Simulated Annealing Optimization** - Iterative refinement to minimize wirelength

The primary optimization objective is to minimize **Half-Perimeter Wirelength (HPWL)**, which directly impacts routing congestion, timing, and power consumption.

---


# Full Flow Walkthrough: Inputs and Outputs

This document describes the complete physical design flow, starting from a logical netlist and ending with routed layout and static timing analysis. Each step depends on artifacts generated by the previous steps, so running `make all` or `make sta` will automatically execute the entire flow in the correct order.

---

## Initial Inputs (Required Files)

The following files must be present before running the flow:

- `designs/arith_mapped.json`  
  Logical design netlist (cells and connectivity)

- `fabric/fabric_cells.yaml`  
  Definitions of available fabric slots

- `fabric/pins.yaml`  
  Pin placement and I/O locations

- `tech/sky130_fd_sc_hd__tt_025C_1v80.lib`  
  Liberty timing library

- `tech/sky130_fd_sc_hd_merged.lef`  
  Technology LEF file

---

## Step 1: Greedy Placement (`make greedy`)

### Inputs
- `designs/arith_mapped.json` ‚Äî design netlist  
- `fabric/fabric_cells.yaml` ‚Äî fabric slot definitions  
- `fabric/pins.yaml` ‚Äî pin locations  

### Outputs
- `build/arith/arith_placement.json`  
  Initial placement (logical cell ‚Üí fabric slot mapping)

- `build/arith/arith.map`  
  Placement map file (logical_name ‚Üí physical_slot_name)

### Description
Places logical cells onto available fabric slots using a greedy algorithm that minimizes estimated wirelength.

---

## Step 2: Simulated Annealing Placement (`make sa`)

### Inputs
- `build/arith/arith_placement.json` ‚Äî initial placement from greedy step  
- `designs/arith_mapped.json` ‚Äî design netlist  
- `fabric/fabric_cells.yaml` ‚Äî fabric slots  
- `fabric/pins.yaml` ‚Äî pin locations  

### Outputs
- `build/arith/arith_sa_placement.json`  
  Optimized placement after simulated annealing

- `build/arith/arith_sa.map`  
  Updated placement map (logical_name ‚Üí physical_slot_name)

### Description
Improves the greedy placement using simulated annealing  
(Œ± = 0.97, moves = 700, T_final = 0.001) to further reduce wirelength.

---

## Step 3: Clock Tree Synthesis (CTS) & ECO (`make cts_eco`)

### Inputs
- `build/arith/arith_sa_placement.json` ‚Äî SA placement  
- `build/arith/arith_sa.map` ‚Äî placement map (required for CTS)  
- `designs/arith_mapped.json` ‚Äî design netlist  
- `fabric/fabric_cells.yaml` ‚Äî fabric cells  

### Outputs
- `build/arith/arith_eco.json`  
  Placement JSON with CTS buffers and ECO cells added

- `build/arith/arith_eco.v` (or `arith_final.v`)  
  Verilog netlist including CTS and ECO modifications

- `build/arith/arith_eco.map`  
  Placement map including CTS buffers and ECO cells

### Description
- Generates a clock tree (H-tree) and inserts clock buffers  
- Adds ECO cells (e.g., tying unused logic to `conb_1 LO`)  
- Updates both placement and netlist to reflect newly added cells

---

## Step 4: Instance Renaming (`make rename`)

### Inputs
- `build/arith/arith_eco.v` or `build/arith/arith_final.v`  
  Verilog netlist with logical instance names

- `build/arith/arith_eco.map`  
  Placement map (logical ‚Üí physical mapping)

### Outputs
- `build/arith/arith_renamed.v`  
  Verilog netlist with instances renamed to physical slot names

### Description
Renames all Verilog instances from logical names to physical slot names  
(e.g., `cell_123 ‚Üí T14Y58__R1_DFBBP_0`) to ensure consistency with the placed design.

---

## Step 5: Routing (`make route`)

### Inputs
- `build/arith/arith_renamed.v` ‚Äî renamed Verilog  
- `build/arith/arith_eco.map` ‚Äî placement map  
- `tech/sky130_fd_sc_hd_merged.lef` ‚Äî technology LEF  
- `tech/sky130_fd_sc_hd__tt_025C_1v80.lib` ‚Äî liberty timing library  

### Process
1. `make_def.py` generates an initial DEF:
   - `build/arith/arith.def` (components, pins, nets ‚Äî no routing)

2. `route.tcl` (OpenROAD) performs:
   - Global routing  
   - Detailed routing  
   - SPEF extraction  

### Outputs
- `build/arith/arith.def`  
  Initial DEF file (unrouted)

- `build/arith/arith_routed.def`  
  Final DEF with complete routing (metal layers, tracks, vias)

- `build/arith/arith.spef`  
  Extracted parasitic RC data (SPEF)

### Description
Routes all nets through metal layers, creating complete physical wire connections between cells.

---

## Step 6: Static Timing Analysis (STA) (`make sta`)

### Inputs
- `build/arith/arith_routed.def` ‚Äî routed design  
- `build/arith/arith_renamed.v` ‚Äî renamed Verilog  
- `build/arith/arith.spef` ‚Äî parasitic RC data  
- `tech/sky130_fd_sc_hd_merged.lef` ‚Äî technology LEF  
- `tech/sky130_fd_sc_hd__tt_025C_1v80.lib` ‚Äî timing library  
- `sdc/arith.sdc` ‚Äî timing constraints  

### Outputs
- `build/arith/arith_setup.rpt`  
  Setup timing report

- `build/arith/arith_hold.rpt`  
  Hold timing report

- `build/arith/arith_clock_skew.rpt`  
  Clock skew analysis

- `build/arith/arith_timing_summary.rpt`  
  Overall timing summary

### Description
Analyzes timing paths, computes delays using extracted parasitics, checks setup and hold constraints, and reports worst-case timing and slack.

---

## Summary Flow Diagram

```text
designs/arith_mapped.json
fabric/fabric_cells.yaml
fabric/pins.yaml
        ‚Üì
[ Step 1: Greedy Placement ]
        ‚Üì
arith_placement.json
arith.map
        ‚Üì
[ Step 2: Simulated Annealing ]
        ‚Üì
arith_sa_placement.json
arith_sa.map
        ‚Üì
[ Step 3: CTS & ECO ]
        ‚Üì
arith_eco.json
arith_eco.v / arith_final.v
arith_eco.map
        ‚Üì
[ Step 4: Instance Rename ]
        ‚Üì
arith_renamed.v
        ‚Üì
[ Step 5: Routing ]
        ‚Üì
arith_routed.def
arith.spef
        ‚Üì
[ Step 6: STA ]
        ‚Üì
arith_setup.rpt
arith_hold.rpt
arith_clock_skew.rpt
arith_timing_summary.rpt


## üÜï New Features (v2.0)

### üé¨ Animation System
Visualize physical design algorithms in real-time with MP4 video generation:
- **SA Placement Animation** - Watch simulated annealing optimize cell placement
- **CTS Tree Animation** - Visualize H-Tree and X-Tree clock distribution networks
- **Congestion Heatmaps** - Animated routing congestion visualization

```bash
python animate_sa_placement.py --design 6502 --fps 10
python create_cts_animations.py  # Creates both H-Tree and X-Tree videos
```

### üå≥ Clock Tree Synthesis (CTS)
Complete CTS implementation with buffer management:
- **H-Tree**: Balanced horizontal/vertical partitioning
- **X-Tree**: Diagonal NW/SE and NE/SW partitioning
- **Buffer Manager**: Automatic buffer allocation from fabric slots

### üõ£Ô∏è Automated Routing
OpenROAD-based routing with automatic error recovery:
```bash
python auto_route.py 6502  # Iteratively routes design, excluding problematic cells
```

### ‚è±Ô∏è SDC Generation
Automatic timing constraint generation for STA:
```bash
python generate_sdc.py --design all  # Generates SDC for all designs
```

üìñ See [CHANGELOG.md](CHANGELOG.md) for full details on new features.

---

## Design Flow Architecture

### Phase 1: Database Construction and Validation

#### **Core Parsing Modules**

**`parse_design.py`**

- **Input**: Yosys-generated mapped JSON file (e.g., `designs/6502_mapped.json`)
- **Output**:
  - `logical_db`: Dictionary mapping cell types to their instance counts
  - `netlist_graph`: Dictionary mapping instance names to their connections and types
- **Function**: Extracts the netlist connectivity, where each cell's connections are represented as lists of net IDs (integers) that define the electrical connectivity between components

**`parse_fabric.py`**

- **Input**: Fabric definition YAML files (`fabric/fabric_cells.yaml`, `fabric/pins.yaml`)
- **Output**:
  - `fabric_db`: Dictionary mapping cell types to lists of available physical slots with coordinates (x, y) in microns and orientations
  - `pins_db`: Dictionary containing die dimensions, core area, and fixed I/O pin locations
- **Function**: Builds the physical slot inventory and I/O pin database that defines the available placement locations

**`validator.py`**

- **Function**: Pre-placement validation ensuring:
  - All logical cell types in the design have corresponding fabric slots
  - Sufficient slots exist for each cell type (capacity check)
  - Design feasibility verification before attempting placement
- **Behavior**: Exits with error if validation fails, preventing invalid placements

**`visualize.py`**

- **Function**: Generates visual representations of:
  - Fabric slot layouts
  - Placement quality heatmaps
  - Net length distributions
  - Design analysis and debugging visualizations

---

### Phase 2: Greedy Barycenter Placement

The greedy algorithm establishes an initial high-quality placement using a two-stage approach:

#### **Stage 1: I/O-Connected Cell Placement (Seed Placement)**

**Function**: `place_io_connected_cells_optimized()`

- Identifies all cells directly connected to fixed I/O pins
- For each I/O cell, calculates the **barycenter** (center of gravity) of all connected pin locations
- Places each cell at the nearest available fabric slot to its barycenter
- **Purpose**: Minimizes I/O-to-logic wirelength, which is critical since I/O pins are fixed

**Key Optimization**: Uses KD-tree spatial indexing for O(log n) nearest-slot lookup instead of O(n) linear search

#### **Stage 2: Connectivity-Driven Placement**

**Function**: `place_greedy_barycenter_optimized()`

- Uses a priority queue where cells with more placed neighbors are prioritized
- For each unplaced cell:
  1. Find all already-placed neighbors (cells sharing nets)
  2. Calculate barycenter of neighbor positions
  3. Place at nearest available slot to the barycenter
  4. **Incrementally update** only affected cell priorities (not full recomputation)

**Scoring Function**: `(num_placed_neighbors, total_connections)`

- Primary: Maximize placed neighbors (ensures connected cells cluster together)
- Secondary: Total connection count (breaks ties)

**Key Optimizations**:

- Pre-built net-to-cells index for O(1) neighbor lookups
- Incremental score updates (only affected cells recalculated after each placement)
- KD-tree spatial indexing for fast nearest-slot searches
- Efficient handling of I/O pin connectivity in barycenter calculation

---

### Phase 3: Simulated Annealing Optimization

Simulated Annealing (SA) is a probabilistic optimization technique that refines the greedy placement by exploring the solution space through controlled randomness.

#### **Key Concept**

SA allows exploring better placements by occasionally accepting worse moves early on, enabling escape from local minima that greedy algorithms get trapped in.

#### **Algorithm Flow**

```
Initialize: T = T_initial, placement = greedy_placement, W = W_initial
while T > T_final:
    for i = 1 to moves_per_temp:
        1. Propose a move (refine or explore)
        2. Calculate ŒîE = HPWL_new - HPWL_current
        3. Accept move if:
           - ŒîE < 0 (improvement) ‚Üí Always accept
           - ŒîE ‚â• 0 (worse) ‚Üí Accept with probability P = e^(-ŒîE/T)
        4. Update current placement if accepted
        5. Track best placement seen so far
    Cool temperature: T = Œ± √ó T
    Shrink window: W = Œ≤ √ó W
```

#### **Move Types (Hybrid Move Set)**

**Refine Move** (`refine_move_optimized()`) - Probability P_refine (default: 0.7)

- **Operation**: Swap two cells of the same type
- **Purpose**: Local optimization and fine-tuning
- **Characteristics**:
  - Preserves slot-type constraints (only swaps compatible cells)
  - Low-disruption moves for polishing placement
  - More effective at low temperatures

**Explore Move** (`explore_move_optimized()`) - Probability P_explore (default: 0.3)

- **Operation**: Move a cell to a random available slot within window W
- **Purpose**: Global exploration and escaping local minima
- **Characteristics**:
  - Window size W shrinks with temperature (Œ≤ = 0.98)
  - Enables large jumps early, small adjustments late
  - Critical for discovering better placement regions

**Adaptive Strategy**:

- High temperature (early): More exploration moves accepted ‚Üí global search
- Low temperature (late): Mostly refinement moves ‚Üí fine-tuning
- Window cooling ensures spatial locality increases over time

#### **Acceptance Criterion (Metropolis)**

**Case 1**: If ŒîE < 0 (improvement)

- **Always accept** - placement is better

**Case 2**: If ŒîE ‚â• 0 (worse placement)

- Accept with probability: **P = e^(-ŒîE/T)**
- High T ‚Üí High P ‚Üí Accept many bad moves ‚Üí Exploration
- Low T ‚Üí Low P ‚Üí Accept few bad moves ‚Üí Refinement

#### **Cooling Schedule**

**Temperature**: T_new = Œ± √ó T_old

- Œ± ‚âà 0.95‚Äì0.99 (typical range)
- Slower cooling (Œ± closer to 1.0) = better quality, longer runtime
- Our default: Œ± = 0.95

**Window Size**: W_new = Œ≤ √ó W_old

- Œ≤ ‚âà 0.98 (default)
- Minimum window = 10% of die width (prevents over-localization)
- Initial window = 50% of die width

#### **Critical Optimizations**

**1. Incremental HPWL Calculation** (10-100√ó speedup)

- Original: Recalculate HPWL for **all nets** on every move
- Optimized: Only recalculate **affected nets** (nets connected to moved cells)
- Implementation:
  ```python
  affected_nets = get_affected_nets([cell1, cell2], cell_to_nets)
  delta_cost = calculate_incremental_delta(affected_nets, old_placement, new_placement)
  ```

**2. Pre-built Slot Lookup** (eliminates O(n) overhead)

- Built once before SA loop: `slot_lookup[slot_name] ‚Üí slot_dict`
- Passed to all move functions
- Eliminates repeated fabric_db traversal

**3. Pre-computed Cell-to-Nets Mapping**

- `cell_to_nets[cell_name] ‚Üí set(net_ids)`
- Enables O(1) lookup of which nets are affected by a move
- Critical for incremental HPWL calculation

**Expected Performance**: These optimizations reduce SA runtime from hours to minutes for typical designs.

---

### Phase 4: Clock Tree Synthesis, ECO, and Instance Renaming

After placement optimization, the design undergoes clock tree synthesis, engineering change orders, and instance renaming to prepare for routing.

#### **Clock Tree Synthesis (CTS)**

**Function**: `eco_generator.py` with `--enable-cts`

- **Purpose**: Distributes clock signals from a single source to all sequential elements (flip-flops, latches) with balanced delays
- **Implementation**: Supports two tree topologies:
  - **H-Tree** (`--cts-tree-type h`): Balanced horizontal/vertical partitioning for uniform clock distribution
  - **X-Tree** (`--cts-tree-type x`): Diagonal NW/SE and NE/SW partitioning for alternative routing patterns
- **Buffer Management**: Automatically allocates clock buffers (`clkbuf_4`, `clkinv_2`) from available fabric slots
- **Output**: Adds clock buffer instances to the placement and updates the netlist with clock tree connections

**Key Files**:
- `cts_api.py` - CTS API interface
- `cts_htree.py` - H-Tree implementation
- `cts_xtree.py` - X-Tree implementation
- `buffer_manager.py` - Buffer allocation from fabric slots

#### **Engineering Change Order (ECO)**

**Function**: `eco_generator.py`

- **Purpose**: Adds necessary cells to ensure design correctness and manufacturability
- **Common ECO Operations**:
  - Tying unused logic inputs to constant values (e.g., `conb_1 LO` for tie-low)
  - Adding decoupling capacitors (`decap_3`, `decap_4`) for power integrity
  - Inserting tap cells (`tapvpwrvgnd_1`) for substrate biasing
- **Output**: 
  - `build/<design>/<design>_eco.json` - Updated placement including ECO cells
  - `build/<design>/<design>_eco.v` - Verilog netlist with CTS and ECO modifications
  - `build/<design>/<design>_eco.map` - Placement map including all new cells

#### **Instance Renaming (`rename.py`)**

**Function**: `rename.py` (or `make rename`)

- **Purpose**: Maps logical instance names from synthesis to physical slot names from placement
- **Process**:
  1. Reads placement map (`<design>_eco.map`) containing logical ‚Üí physical mappings
  2. Parses Verilog netlist (`<design>_eco.v`) with logical instance names
  3. Renames all instances to match physical slot names (e.g., `cell_123 ‚Üí T14Y58__R1_DFBBP_0`)
- **Why Required**: Routing tools (OpenROAD) need physical slot names to match the DEF file generated from placement
- **Output**: `build/<design>/<design>_renamed.v` - Verilog with physical instance names

**Key Validation**:
- Ensures all logical instances in Verilog have corresponding entries in the placement map
- Verifies no duplicate physical slot assignments
- Checks that renamed instances match DEF file component names

---

### Phase 5: Routing and Static Timing Analysis

The final phases convert the placed and renamed design into a fully routed layout and perform timing verification.

#### **Routing (`route.tcl`)**

**Function**: OpenROAD routing script (`route.tcl`)

- **Purpose**: Creates physical wire connections between all placed cells using metal layers
- **Two-Stage Process**:

  1. **Global Routing**:
     - Divides the design into routing grid cells (GCells)
     - Assigns nets to routing tracks and layers
     - Generates routing guides (coarse paths) for each net
     - Produces congestion analysis and reports
     - Output: `build/<design>/<design>_global_routed.def`

  2. **Detailed Routing**:
     - Implements actual metal wires, vias, and connections following global routing guides
     - Performs DRC (Design Rule Check) compliance
     - Handles pin access and via generation
     - Iterative repair for routing violations
     - Output: `build/<design>/<design>_routed.def`

- **Parasitic Extraction**:
  - Extracts resistance and capacitance (RC) values from routed wires
  - Uses extraction rules file (`rcx_patterns.rules`) for accurate modeling
  - Output: `build/<design>/<design>.spef` (Standard Parasitic Exchange Format)

**Key Features**:
- Automatic error recovery with iterative routing attempts
- Pin access analysis before routing
- Congestion-aware routing with overflow handling
- Support for multiple metal layers (met1-met5 in Sky130)

**Usage**:
```bash
export DESIGN_NAME=6502
export BUILD_DIR=build
export LIBERTY_FILE=tech/sky130_fd_sc_hd__tt_025C_1v80.lib
export LEF_FILE=tech/sky130_fd_sc_hd_merged.lef
openroad -exit route.tcl
```

#### **Static Timing Analysis (`sta.tcl`)**

**Function**: OpenROAD/OpenSTA timing analysis script (`sta.tcl`)

- **Purpose**: Verifies that the routed design meets timing constraints (setup, hold, clock skew)
- **Inputs Required**:
  - `build/<design>/<design>_renamed.v` - Renamed Verilog netlist
  - `build/<design>/<design>.spef` - Extracted parasitic RC data
  - `sdc/<design>.sdc` - Timing constraints (clock definitions, input/output delays)
  - `tech/sky130_fd_sc_hd_merged.lef` - Technology LEF
  - `tech/sky130_fd_sc_hd__tt_025C_1v80.lib` - Liberty timing library

- **Analysis Performed**:
  1. **Setup Time Checks**: Verifies data arrives before clock edge (max delay paths)
  2. **Hold Time Checks**: Verifies data remains stable after clock edge (min delay paths)
  3. **Clock Skew Analysis**: Measures clock arrival time differences across the design
  4. **Timing Summary**: Overall timing metrics and worst-case paths

- **Output Reports**:
  - `build/<design>/<design>_setup.rpt` - Setup timing violations and worst paths
  - `build/<design>/<design>_hold.rpt` - Hold timing violations
  - `build/<design>/<design>_clock_skew.rpt` - Clock distribution analysis
  - `build/<design>/<design>_timing_summary.rpt` - Overall timing summary

**Key Metrics Reported**:
- Slack (positive = meets timing, negative = violation)
- Path delay (propagation time through combinational logic)
- Clock-to-Q delay (sequential element output delay)
- Setup/Hold time margins

**Usage**:
```bash
export DESIGN_NAME=6502
export BUILD_DIR=build
export LIBERTY_FILE=tech/sky130_fd_sc_hd__tt_025C_1v80.lib
export SDC_FILE=sdc/6502.sdc
openroad -exit sta.tcl
```

**Timing Closure Flow**:
If timing violations are found, the design may need:
- Placement refinement (re-run SA with timing-aware objectives)
- Buffer insertion for long paths
- Clock tree optimization
- Constraint relaxation (if over-constrained)

---

## Visualization and Analysis Tools

### **Heatmap Generation** (`plot_fabric_with_placement.py`)

Generates placement quality heatmaps showing:

- Cell density distribution across the fabric
- Hotspot identification (over-utilized regions)
- Placement uniformity metrics
- Comparison between greedy and SA placements

### **Net Length Histograms** (`plot_net_length_histogram.py`)

Produces distribution plots of:

- HPWL per net (identifies critical nets)
- Net length statistics (mean, median, max)
- Comparison across different SA parameter configurations

### **Automated Parameter Sweep**

Runs multiple SA configurations with varying:

- `alpha`: Cooling rate (0.90‚Äì0.99)
- `moves_per_temp`: Iterations per temperature (50‚Äì1000)
- `T_final`: Stopping temperature (0.001‚Äì0.1)

Results stored in: `build/<design_name>/<SA_parameters>/`

Each run includes:

- `<config>_heatmap.png` - Placement heatmap
- `<design>.map` - Logical-to-physical mapping
- `<design>_placement.json` - Full placement data

Best run stored separately in: `build/<design_name>/Best_<config>/`

---

## Results: 6502 Microprocessor Design

### **Performance vs Quality Trade-off**

![Runtime vs HPWL](build/6502/runtime_vs_hpwl_6502.png)

**Key Observations**:

- Diminishing returns with longer SA runs
- Sweet spot around Œ±=0.99, moves=1000, T_final=0.001
- **38.72% HPWL improvement** over greedy-only placement (431,210.20 Œºm ‚Üí 264,256.14 Œºm)
- Demonstrates effectiveness of SA in escaping local minima
- Detailed net length distribution analysis shown in histogram comparison below

### **Best Configuration Results**

**Parameters**: `alpha=0.99, moves_per_temp=1000, T_final=0.001`

**Heatmap Comparison**:

| Greedy Only                                             | After SA Optimization                                                                                            |
| ------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------- |
| ![Greedy Heatmap](build/6502/greedy/greedy_heatmap.png) | ![SA Heatmap](build/6502/Best_sa_alpha0.99_moves1000_Tfinal0.001/sa_alpha0.99_moves1000_Tfinal0.001_heatmap.png) |

**Analysis**:

- Greedy placement shows clustering around I/O regions (expected from seed placement)
- SA redistributes cells more evenly across the fabric
- Hotspots reduced, indicating better load balancing
- Global exploration moves enabled discovery of non-intuitive but superior placements
- **HPWL Results**: 38.72% reduction (166,954.06 Œºm improvement) - see histogram analysis below for detailed distribution changes

### **Net Length Distribution**

| Greedy Placement                                        | After SA Optimization                                                                   |
| ------------------------------------------------------- | --------------------------------------------------------------------------------------- |
| ![Greedy Histogram](build/6502/greedy/greedyHisto.jpeg) | ![SA Histogram](build/6502/Best_sa_alpha0.99_moves1000_Tfinal0.001/histogram_final.png) |

**Quantitative Results from Histogram Analysis**:

- **Total HPWL Reduction**: 38.72% improvement (431,210.20 Œºm ‚Üí 264,256.14 Œºm)
- **Absolute Reduction**: 166,954.06 Œºm reduction in total wirelength
- **Distribution Shift**: SA histogram shows significant reduction in long net counts
- **Mean HPWL Reduction**: Visible decrease in average net length (see histogram statistics)
- **Long Net Optimization**: SA preferentially reduces nets in higher HPWL ranges (>500 Œºm)
- **‚ö†Ô∏è Trade-off - Maximum Net Length**: The maximum net length increases in SA-optimized placement, which is a negative aspect. While SA improves overall distribution and total HPWL, it may create a few extremely long nets as a side effect of global optimization

**Insights**:

- Most nets have short HPWL (good locality) in both placements, confirming good initial greedy placement
- Long-tail distribution indicates a few critical long nets that SA successfully optimizes
- **SA successfully reduces long net lengths more than short nets** - visible shift in distribution toward shorter nets
- Greedy placement shows more nets in the longer HPWL ranges (right tail of distribution)
- Distribution shift toward shorter nets in SA histogram confirms optimization effectiveness
- The contrast demonstrates SA's ability to escape local minima and find globally better placements
- **Key Observation**: The histogram comparison visually confirms the 38.72% total HPWL reduction, with the SA histogram showing fewer nets in high HPWL bins and more nets concentrated in lower HPWL ranges
- **Important Trade-off**: While SA dramatically improves total HPWL and average net lengths, the maximum net length increases. This is a known limitation where global optimization prioritizes overall wirelength reduction over eliminating the longest individual nets, which may impact timing-critical paths

---

## Command-Line Usage

### **Basic Placement (Greedy + SA)**

```bash
python placer.py --design designs/6502_mapped.json \
                 --fabric-cells fabric/fabric_cells.yaml \
                 --pins fabric/pins.yaml \
                 --output build/6502
```

### **Greedy Only (No SA)**

```bash
python placer.py --design designs/6502_mapped.json --no-sa
```

### **Custom SA Parameters**

```bash
python placer.py --design designs/6502_mapped.json \
                 --sa-alpha 0.99 \
                 --sa-moves 1000 \
                 --sa-T-final 0.001
```

### **Parameter Sweep**

```bash
python run_parameter_sweep.py --design designs/6502_mapped.json
```

---

## Output Files

### **Placement Map** (`<design>.map`)

```
cpu.U_alu.add_1 T0Y0__R0_NAND_42
cpu.U_alu.add_2 T0Y0__R0_NAND_43
...
```

Format: `logical_instance_name physical_slot_name`

### **Placement JSON** (`<design>_placement.json`)

```json
{
  "cpu.U_alu.add_1": {
    "fabric_slot_name": "T0Y0__R0_NAND_42",
    "x": 125.5,
    "y": 87.3,
    "orient": "N"
  },
  ...
}
```

### **Run Logs** (`build/<design>/logs/`)

- Detailed SA progress tracking
- Temperature, HPWL, acceptance rates per iteration
- Move type statistics (refine vs explore)
- Final improvement metrics

---

## Key Algorithmic Insights

### **Why Greedy Gets Stuck**

Greedy algorithms make locally optimal choices but can't backtrack:

- Once a cell is placed, it's fixed
- May create sub-optimal clusters that block better global arrangements
- No mechanism to escape local minima

### **How SA Escapes Local Minima**

1. **Early Phase (High T)**:

   - Accepts ~50% of worse moves
   - Explores radically different configurations
   - Discovers promising regions of solution space

2. **Middle Phase (Medium T)**:

   - Accepts ~20% of worse moves
   - Balances exploration with exploitation
   - Refines promising solutions while still exploring

3. **Late Phase (Low T)**:
   - Accepts <5% of worse moves
   - Fine-tunes final placement
   - Converges to local optimum (hopefully global)

### **Why Incremental HPWL is Critical**

**Without Optimization**:

- Each move touches 2 cells
- Those 2 cells might be on 10 nets total
- But we recalculate HPWL for ALL 10,000 nets in the design
- 99.9% of calculations are wasted!

**With Optimization**:

- Identify 10 affected nets
- Recalculate only those 10
- 1000√ó fewer calculations
- Same result, vastly faster

---

## References

- Yosys Open Synthesis Suite: [https://github.com/YosysHQ/yosys](https://github.com/YosysHQ/yosys)
- Simulated Annealing: Kirkpatrick, S., Gelatt, C. D., & Vecchi, M. P. (1983)
- VLSI Placement Algorithms: Kahng, A. B., Lienig, J., Markov, I. L., & Hu, J. (2011)

---

## Project Structure

```
structured_asic_project/
‚îú‚îÄ‚îÄ placer.py                          # Main placement engine
‚îú‚îÄ‚îÄ parse_design.py                     # Netlist parser
‚îú‚îÄ‚îÄ parse_fabric.py                     # Fabric definition parser
‚îú‚îÄ‚îÄ validator.py                        # Design feasibility checker
‚îú‚îÄ‚îÄ visualize.py                        # Visualization utilities
‚îú‚îÄ‚îÄ plot_fabric_with_placement.py      # Heatmap generator
‚îú‚îÄ‚îÄ plot_net_length_histogram.py       # Net distribution plots
‚îú‚îÄ‚îÄ run_parameter_sweep.py             # Automated SA tuning
‚îÇ
‚îú‚îÄ‚îÄ # NEW: Animation System
‚îú‚îÄ‚îÄ animate_sa_placement.py            # SA optimization animation
‚îú‚îÄ‚îÄ animate_cts_tree.py                # CTS tree animation
‚îú‚îÄ‚îÄ animate_congestion.py              # Congestion heatmap animation
‚îú‚îÄ‚îÄ animate_net_hpwl.py                # Net wirelength animation
‚îú‚îÄ‚îÄ create_cts_animations.py           # Wrapper for CTS animations
‚îÇ
‚îú‚îÄ‚îÄ # NEW: Clock Tree Synthesis
‚îú‚îÄ‚îÄ cts_api.py                         # CTS API
‚îú‚îÄ‚îÄ cts_htree.py                       # H-Tree implementation
‚îú‚îÄ‚îÄ cts_xtree.py                       # X-Tree implementation
‚îú‚îÄ‚îÄ buffer_manager.py                  # Buffer allocation manager
‚îú‚îÄ‚îÄ cts_simulator.py                   # CTS timing simulation
‚îÇ
‚îú‚îÄ‚îÄ # NEW: Routing Support
‚îú‚îÄ‚îÄ auto_route.py                      # Automated routing loop
‚îú‚îÄ‚îÄ make_def.py                        # DEF file generator (modified)
‚îú‚îÄ‚îÄ route.tcl                          # OpenROAD routing script
‚îú‚îÄ‚îÄ extract_drt_errors.py              # Error log parser
‚îÇ
‚îú‚îÄ‚îÄ # NEW: SDC Generation
‚îú‚îÄ‚îÄ generate_sdc.py                    # SDC constraint generator
‚îÇ
‚îú‚îÄ‚îÄ fabric/
‚îÇ   ‚îú‚îÄ‚îÄ fabric_cells.yaml              # Physical slot definitions
‚îÇ   ‚îî‚îÄ‚îÄ pins.yaml                       # I/O pin locations
‚îú‚îÄ‚îÄ designs/
‚îÇ   ‚îî‚îÄ‚îÄ 6502_mapped.json               # Example: 6502 microprocessor
‚îú‚îÄ‚îÄ tech/
‚îÇ   ‚îú‚îÄ‚îÄ sky130_fd_sc_hd.lef            # Cell LEF (modified)
‚îÇ   ‚îú‚îÄ‚îÄ sky130_fd_sc_hd.tlef           # Technology LEF (modified)
‚îÇ   ‚îî‚îÄ‚îÄ sky130_fd_sc_hd_merged.lef     # Merged LEF for routing
‚îú‚îÄ‚îÄ sdc/
‚îÇ   ‚îî‚îÄ‚îÄ *.sdc                          # Generated SDC files
‚îî‚îÄ‚îÄ build/
    ‚îî‚îÄ‚îÄ 6502/
        ‚îú‚îÄ‚îÄ greedy/
        ‚îÇ   ‚îú‚îÄ‚îÄ greedy_heatmap.png
        ‚îÇ   ‚îî‚îÄ‚îÄ greedyHisto.jpeg
        ‚îú‚îÄ‚îÄ runtime_vs_hpwl_6502.png
        ‚îú‚îÄ‚îÄ logs/
        ‚îú‚îÄ‚îÄ sa_animation.mp4               # NEW: SA animation
        ‚îú‚îÄ‚îÄ 6502_cts_htree_animation.mp4   # NEW: H-Tree animation
        ‚îú‚îÄ‚îÄ 6502_cts_xtree_animation.mp4   # NEW: X-Tree animation
        ‚îî‚îÄ‚îÄ Best_sa_alpha0.99_moves1000_Tfinal0.001/
            ‚îú‚îÄ‚îÄ sa_alpha0.99_moves1000_Tfinal0.001_heatmap.png
            ‚îú‚îÄ‚îÄ histogram_final.png
            ‚îú‚îÄ‚îÄ 6502.map
            ‚îî‚îÄ‚îÄ 6502_placement.json
```

_Note: Run the analysis script to generate the plot and see actual results for your design._

## Design-Specific Highlights

| Design | Best SA configuration (Œ± / moves / T_final) | Output directory                                      |
| ------ | ------------------------------------------- | ----------------------------------------------------- |
| 6502   | 0.99 / 1000 / 0.001                         | build/6502/Best_sa_alpha0.99_moves1000_Tfinal0.001/ |
| arith  | 0.99 / 500 / 0.001                          | build/arith/Best_sa_alpha0.99_moves500_Tfinal0.001/ |

Both designs rely on the auto-calculated initial temperature T_initial = 10,000 √ó HPWL_greedy. For 6502, the greedy seed HPWL of 403,784.5 ¬µm produces T_initial ‚âà 4.0 √ó 10^9, which guarantees near-100 % acceptance at the start and lets SA explore aggressively before cooling. We noted from the logs that this initial temperature might be too high and we intend to reduce the 10000 factor to 10 to 100.

### 6502 (heavy exploration mode)

- *What we ran:* Exhaustive sweep across Œ±‚àà[0.90,0.99], moves‚àà[300,1000], T_final‚àà{0.001,0.01,0.1}. Logs for every run live in build/6502/logs/.

- *Best-quality knob set:* Œ±=0.99, moves=1000, T_final=0.001. Artifacts (heatmaps + histograms) are under build/6502/Best_sa_alpha0.99_moves1000_Tfinal0.001/. Comparative figures:

  - Greedy: build/6502/greedy/greedy_heatmap.png, build/6502/greedy/greedyHisto.jpeg

  - SA vs. Greedy runtime/HPWL frontier: build/6502/runtime_vs_hpwl_6502.png

- *Measured impact (log):* build/6502/logs/6502_sa_a0.99_m1000_T0.001.log shows the greedy baseline at *431,210 ¬µm* and the SA result at *264,256 ¬µm, a drop of **166,954 ¬µm (‚àí38.7 %)*.

- *Distribution insight (histogram):* build/6502/Best_sa_alpha0.99_moves1000_Tfinal0.001/histogram_final.png still highlights the dramatic shrink in median HPWL (88.8 ‚Üí 31.5 ¬µm) and mean (155.5 ‚Üí 95.6 ¬µm), even though a few long global nets stretch to ~1.95 mm.

- *Why SA beats greedy:* Greedy prefers hugging IO pins, producing dense pockets and elongated cross-chip nets once clusters connect to distant logic. SA starts with randomized moves accepted under the high T_initial, then gradually cools (Œ±=0.99) while still trying 1000 moves per temperature step. The random exploration plus uphill acceptance in early stages loosens greedy clusters, redistributes congestion, and lowers overall HPWL even though a handful of long nets get longer.

![6502 Runtime vs HPWL](docs/assets/runtime_vs_hpwl_6502.png)

### arith (moderate exploration mode)

- *What we ran:* Grid over Œ±‚àà[0.80,0.99], moves‚àà[50,500], T_final‚àà{0.1,0.01,0.001}. Logs are stored in build/arith/logs/, and the sweep summary is build/arith/runtime_vs_hpwl_arith.png.

- *Best-quality knob set:* Œ±=0.99, moves=500, T_final=0.001 (see build/arith/Best_sa_alpha0.99_moves500_Tfinal0.001/). The heavier schedule is still the clear QoR leader, while the balanced point (Œ±=0.98, moves=300, T_final=0.01) trades ~12% higher HPWL for ~45% faster runtime.

- *Measured impact (log):* build/arith/logs/arith_sa_a0.99_m500_T0.001.log captures the greedy HPWL at *165,616 ¬µm* and the SA finish at *50,216.99 ¬µm* ‚Äì a reduction of *115,399 ¬µm (‚àí69.6 %)*.

- *Behavioral notes:* Arith starts from a much cleaner greedy solution, so extreme SA settings primarily polish local structure. The moderate Œ±/moves combos already converge well, and higher initial temperature still helps escape small pockets without the drastic congestion-shifting seen in 6502.
```
